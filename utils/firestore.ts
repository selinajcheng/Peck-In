import {
  collection,
  doc,
  getDoc,
  getDocs,
  addDoc,
  setDoc,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  limit,
  WhereFilterOp,
} from 'firebase/firestore';
import { db } from './firebase';

/**
 * Generic interface for Firestore documents with optional ID field.
 * Extend this interface for type-safe document operations.
 */
export interface FirestoreDocument {
  id?: string;
  [key: string]: any;
}

/**
 * Creates a new document in a Firestore collection with auto-generated ID.
 * The document ID is automatically generated by Firestore.
 *
 * @template T - Type extending FirestoreDocument for type safety
 * @param {string} collectionName - Name of the Firestore collection
 * @param {Omit<T, 'id'>} data - Document data without the ID field
 * @returns {Promise<string>} Promise that resolves to the auto-generated document ID
 * @throws {Error} Throws error if collection name is invalid, data is malformed, or network issues
 *
 * @example
 * ```typescript
 * // Define a user interface
 * interface User extends FirestoreDocument {
 *   name: string;
 *   email: string;
 *   age: number;
 *   createdAt: Date;
 * }
 *
 * // Create a new user document
 * try {
 *   const userId = await createDocument<User>('users', {
 *     name: 'John Doe',
 *     email: 'john@example.com',
 *     age: 30,
 *     createdAt: new Date()
 *   });
 *   console.log('User created with ID:', userId);
 * } catch (error) {
 *   console.error('Failed to create user:', error.message);
 * }
 *
 * // Create a blog post
 * interface BlogPost extends FirestoreDocument {
 *   title: string;
 *   content: string;
 *   authorId: string;
 *   publishedAt: Date;
 *   tags: string[];
 * }
 *
 * const postId = await createDocument<BlogPost>('posts', {
 *   title: 'My First Post',
 *   content: 'This is the content...',
 *   authorId: userId,
 *   publishedAt: new Date(),
 *   tags: ['tech', 'firebase']
 * });
 * ```
 */
export const createDocument = async <T extends FirestoreDocument>(
  collectionName: string,
  data: Omit<T, 'id'>
): Promise<string> => {
  try {
    const docRef = await addDoc(collection(db, collectionName), data);
    return docRef.id;
  } catch (error) {
    console.error('Error creating document:', error);
    throw error;
  }
};

/**
 * Creates or overwrites a document with a specific ID in a Firestore collection.
 * If the document exists, it will be completely overwritten.
 *
 * @template T - Type extending FirestoreDocument for type safety
 * @param {string} collectionName - Name of the Firestore collection
 * @param {string} docId - Specific document ID to use
 * @param {Omit<T, 'id'>} data - Document data without the ID field
 * @returns {Promise<void>} Promise that resolves when document is created/updated
 * @throws {Error} Throws error if collection name is invalid, data is malformed, or network issues
 *
 * @example
 * ```typescript
 * // Create user profile with specific ID (e.g., Firebase Auth UID)
 * interface UserProfile extends FirestoreDocument {
 *   displayName: string;
 *   bio: string;
 *   profilePicture?: string;
 *   preferences: {
 *     theme: 'light' | 'dark';
 *     notifications: boolean;
 *   };
 * }
 *
 * try {
 *   const userId = 'auth_user_123';
 *   await setDocument<UserProfile>('profiles', userId, {
 *     displayName: 'Jane Smith',
 *     bio: 'Software developer passionate about React Native',
 *     preferences: {
 *       theme: 'dark',
 *       notifications: true
 *     }
 *   });
 *   console.log('Profile created/updated for user:', userId);
 * } catch (error) {
 *   console.error('Failed to set profile:', error.message);
 * }
 *
 * // Create settings document with app version as ID
 * interface AppSettings extends FirestoreDocument {
 *   features: string[];
 *   maintenanceMode: boolean;
 *   apiVersion: string;
 * }
 *
 * await setDocument<AppSettings>('settings', 'v1.0.0', {
 *   features: ['auth', 'firestore', 'push-notifications'],
 *   maintenanceMode: false,
 *   apiVersion: '1.0.0'
 * });
 * ```
 */
export const setDocument = async <T extends FirestoreDocument>(
  collectionName: string,
  docId: string,
  data: Omit<T, 'id'>
): Promise<void> => {
  try {
    await setDoc(doc(db, collectionName, docId), data);
  } catch (error) {
    console.error('Error setting document:', error);
    throw error;
  }
};

/**
 * Retrieves a single document from Firestore by its ID.
 * Returns null if the document doesn't exist.
 *
 * @template T - Type extending FirestoreDocument for type safety
 * @param {string} collectionName - Name of the Firestore collection
 * @param {string} docId - Document ID to retrieve
 * @returns {Promise<T | null>} Promise that resolves to the document data with ID, or null if not found
 * @throws {Error} Throws error if collection name is invalid or network issues
 *
 * @example
 * ```typescript
 * // Get user by ID
 * interface User extends FirestoreDocument {
 *   name: string;
 *   email: string;
 *   age: number;
 * }
 *
 * try {
 *   const user = await getDocument<User>('users', 'user123');
 *   if (user) {
 *     console.log('Found user:', user.name, user.email);
 *     console.log('Document ID:', user.id);
 *   } else {
 *     console.log('User not found');
 *   }
 * } catch (error) {
 *   console.error('Failed to get user:', error.message);
 * }
 *
 * // Get current user profile
 * const UserProfile = () => {
 *   const [profile, setProfile] = useState(null);
 *   const { user } = useAuth();
 *
 *   useEffect(() => {
 *     const fetchProfile = async () => {
 *       if (user) {
 *         const userProfile = await getDocument('profiles', user.uid);
 *         setProfile(userProfile);
 *       }
 *     };
 *     fetchProfile();
 *   }, [user]);
 *
 *   return profile ? <Text>Welcome, {profile.displayName}!</Text> : <Text>Loading...</Text>;
 * };
 *
 * // Get app configuration
 * const config = await getDocument('config', 'app-settings');
 * if (config?.maintenanceMode) {
 *   showMaintenanceScreen();
 * }
 * ```
 */
export const getDocument = async <T extends FirestoreDocument>(
  collectionName: string,
  docId: string
): Promise<T | null> => {
  try {
    const docRef = doc(db, collectionName, docId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return { id: docSnap.id, ...docSnap.data() } as T;
    }
    return null;
  } catch (error) {
    console.error('Error getting document:', error);
    throw error;
  }
};

/**
 * Updates specific fields of an existing document in Firestore.
 * Only the provided fields will be updated; other fields remain unchanged.
 *
 * @template T - Type extending FirestoreDocument for type safety
 * @param {string} collectionName - Name of the Firestore collection
 * @param {string} docId - Document ID to update
 * @param {Partial<Omit<T, 'id'>>} data - Partial data object with fields to update
 * @returns {Promise<void>} Promise that resolves when document is updated
 * @throws {Error} Throws error if document doesn't exist, data is invalid, or network issues
 *
 * @example
 * ```typescript
 * // Update user profile
 * interface UserProfile extends FirestoreDocument {
 *   displayName: string;
 *   bio: string;
 *   lastLoginAt: Date;
 *   preferences: {
 *     theme: string;
 *     notifications: boolean;
 *   };
 * }
 *
 * try {
 *   // Update only specific fields
 *   await updateDocument<UserProfile>('profiles', 'user123', {
 *     lastLoginAt: new Date(),
 *     preferences: {
 *       theme: 'dark',
 *       notifications: false
 *     }
 *   });
 *   console.log('Profile updated successfully');
 * } catch (error) {
 *   console.error('Failed to update profile:', error.message);
 * }
 *
 * // Update blog post
 * await updateDocument('posts', 'post456', {
 *   title: 'Updated Title',
 *   updatedAt: new Date()
 * });
 *
 * // Increment a counter
 * import { increment } from 'firebase/firestore';
 * await updateDocument('stats', 'page-views', {
 *   count: increment(1),
 *   lastUpdated: new Date()
 * });
 *
 * // Usage in a component
 * const updateUserPreferences = async (userId: string, preferences: any) => {
 *   try {
 *     await updateDocument('users', userId, { preferences });
 *     Alert.alert('Success', 'Preferences updated successfully');
 *   } catch (error) {
 *     Alert.alert('Error', 'Failed to update preferences');
 *   }
 * };
 * ```
 */
export const updateDocument = async <T extends FirestoreDocument>(
  collectionName: string,
  docId: string,
  data: Partial<Omit<T, 'id'>>
): Promise<void> => {
  try {
    const docRef = doc(db, collectionName, docId);
    await updateDoc(docRef, data);
  } catch (error) {
    console.error('Error updating document:', error);
    throw error;
  }
};

/**
 * Deletes a document from Firestore permanently.
 * This action cannot be undone.
 *
 * @param {string} collectionName - Name of the Firestore collection
 * @param {string} docId - Document ID to delete
 * @returns {Promise<void>} Promise that resolves when document is deleted
 * @throws {Error} Throws error if document doesn't exist or network issues
 *
 * @example
 * ```typescript
 * // Delete user account
 * try {
 *   await deleteDocument('users', 'user123');
 *   console.log('User deleted successfully');
 * } catch (error) {
 *   console.error('Failed to delete user:', error.message);
 * }
 *
 * // Delete blog post with confirmation
 * const deletePost = async (postId: string) => {
 *   Alert.alert(
 *     'Confirm Delete',
 *     'Are you sure you want to delete this post? This action cannot be undone.',
 *     [
 *       { text: 'Cancel', style: 'cancel' },
 *       {
 *         text: 'Delete',
 *         style: 'destructive',
 *         onPress: async () => {
 *           try {
 *             await deleteDocument('posts', postId);
 *             Alert.alert('Success', 'Post deleted successfully');
 *             router.back();
 *           } catch (error) {
 *             Alert.alert('Error', 'Failed to delete post');
 *           }
 *         }
 *       }
 *     ]
 *   );
 * };
 *
 * // Batch delete with cleanup
 * const deleteUserData = async (userId: string) => {
 *   try {
 *     // Delete user profile
 *     await deleteDocument('profiles', userId);
 *     // Delete user settings
 *     await deleteDocument('settings', userId);
 *     // Delete user posts (you might want to use batch operations for this)
 *     console.log('All user data deleted');
 *   } catch (error) {
 *     console.error('Failed to delete user data:', error.message);
 *   }
 * };
 * ```
 */
export const deleteDocument = async (collectionName: string, docId: string): Promise<void> => {
  try {
    await deleteDoc(doc(db, collectionName, docId));
  } catch (error) {
    console.error('Error deleting document:', error);
    throw error;
  }
};

/**
 * Retrieves all documents from a Firestore collection.
 * Use with caution on large collections as it will fetch all documents.
 *
 * @template T - Type extending FirestoreDocument for type safety
 * @param {string} collectionName - Name of the Firestore collection
 * @returns {Promise<T[]>} Promise that resolves to an array of all documents in the collection
 * @throws {Error} Throws error if collection name is invalid or network issues
 *
 * @example
 * ```typescript
 * // Get all users (be careful with large collections)
 * interface User extends FirestoreDocument {
 *   name: string;
 *   email: string;
 *   role: 'admin' | 'user';
 * }
 *
 * try {
 *   const allUsers = await getCollection<User>('users');
 *   console.log(`Found ${allUsers.length} users`);
 *   allUsers.forEach(user => {
 *     console.log(`${user.name} (${user.email}) - ${user.role}`);
 *   });
 * } catch (error) {
 *   console.error('Failed to get users:', error.message);
 * }
 *
 * // Get all categories for a dropdown
 * interface Category extends FirestoreDocument {
 *   name: string;
 *   color: string;
 *   order: number;
 * }
 *
 * const CategoryPicker = () => {
 *   const [categories, setCategories] = useState<Category[]>([]);
 *
 *   useEffect(() => {
 *     const loadCategories = async () => {
 *       try {
 *         const cats = await getCollection<Category>('categories');
 *         // Sort by order field
 *         setCategories(cats.sort((a, b) => a.order - b.order));
 *       } catch (error) {
 *         console.error('Failed to load categories:', error);
 *       }
 *     };
 *     loadCategories();
 *   }, []);
 *
 *   return (
 *     <Picker>
 *       {categories.map(category => (
 *         <Picker.Item key={category.id} label={category.name} value={category.id} />
 *       ))}
 *     </Picker>
 *   );
 * };
 *
 * // Get app settings/configuration
 * const appConfig = await getCollection('config');
 * const features = appConfig.find(config => config.id === 'features');
 * ```
 */
export const getCollection = async <T extends FirestoreDocument>(
  collectionName: string
): Promise<T[]> => {
  try {
    const querySnapshot = await getDocs(collection(db, collectionName));
    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    })) as T[];
  } catch (error) {
    console.error('Error getting collection:', error);
    throw error;
  }
};

/**
 * Queries documents from a Firestore collection with advanced filtering, ordering, and limiting.
 * This is the most powerful function for retrieving specific documents based on criteria.
 *
 * @template T - Type extending FirestoreDocument for type safety
 * @param {string} collectionName - Name of the Firestore collection
 * @param {Object[]} [filters] - Array of filter objects with field, operator, and value
 * @param {string} [orderByField] - Field name to order results by
 * @param {'asc' | 'desc'} [orderDirection='asc'] - Sort direction (ascending or descending)
 * @param {number} [limitCount] - Maximum number of documents to return
 * @returns {Promise<T[]>} Promise that resolves to an array of matching documents
 * @throws {Error} Throws error if query is invalid, field doesn't exist, or network issues
 *
 * @example
 * ```typescript
 * // Query users by role
 * interface User extends FirestoreDocument {
 *   name: string;
 *   email: string;
 *   role: 'admin' | 'user';
 *   createdAt: Date;
 *   isActive: boolean;
 * }
 *
 * try {
 *   // Get all admin users
 *   const admins = await queryDocuments<User>('users', [
 *     { field: 'role', operator: '==', value: 'admin' }
 *   ]);
 *
 *   // Get active users created in the last 30 days, ordered by creation date
 *   const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
 *   const recentActiveUsers = await queryDocuments<User>('users', [
 *     { field: 'isActive', operator: '==', value: true },
 *     { field: 'createdAt', operator: '>=', value: thirtyDaysAgo }
 *   ], 'createdAt', 'desc', 10);
 *
 *   console.log(`Found ${recentActiveUsers.length} recent active users`);
 * } catch (error) {
 *   console.error('Query failed:', error.message);
 * }
 *
 * // Query blog posts
 * interface BlogPost extends FirestoreDocument {
 *   title: string;
 *   content: string;
 *   authorId: string;
 *   publishedAt: Date;
 *   tags: string[];
 *   published: boolean;
 *   views: number;
 * }
 *
 * // Get published posts by specific author, ordered by views
 * const getAuthorPosts = async (authorId: string) => {
 *   return await queryDocuments<BlogPost>('posts', [
 *     { field: 'authorId', operator: '==', value: authorId },
 *     { field: 'published', operator: '==', value: true }
 *   ], 'views', 'desc');
 * };
 *
 * // Get top 5 most viewed posts
 * const topPosts = await queryDocuments<BlogPost>('posts',
 *   [{ field: 'published', operator: '==', value: true }],
 *   'views', 'desc', 5
 * );
 *
 * // Search posts by tag
 * const techPosts = await queryDocuments<BlogPost>('posts', [
 *   { field: 'tags', operator: 'array-contains', value: 'technology' },
 *   { field: 'published', operator: '==', value: true }
 * ], 'publishedAt', 'desc');
 *
 * // Usage in a React component
 * const PostsList = ({ authorId }: { authorId?: string }) => {
 *   const [posts, setPosts] = useState<BlogPost[]>([]);
 *   const [loading, setLoading] = useState(true);
 *
 *   useEffect(() => {
 *     const loadPosts = async () => {
 *       try {
 *         const filters = [{ field: 'published', operator: '==', value: true }];
 *         if (authorId) {
 *           filters.push({ field: 'authorId', operator: '==', value: authorId });
 *         }
 *
 *         const postsData = await queryDocuments<BlogPost>('posts', filters, 'publishedAt', 'desc', 20);
 *         setPosts(postsData);
 *       } catch (error) {
 *         console.error('Failed to load posts:', error);
 *       } finally {
 *         setLoading(false);
 *       }
 *     };
 *
 *     loadPosts();
 *   }, [authorId]);
 *
 *   if (loading) return <Text>Loading posts...</Text>;
 *
 *   return (
 *     <YStack>
 *       {posts.map(post => (
 *         <PostCard key={post.id} post={post} />
 *       ))}
 *     </YStack>
 *   );
 * };
 * ```
 */
export const queryDocuments = async <T extends FirestoreDocument>(
  collectionName: string,
  filters?: {
    field: string;
    operator: WhereFilterOp;
    value: any;
  }[],
  orderByField?: string,
  orderDirection: 'asc' | 'desc' = 'asc',
  limitCount?: number
): Promise<T[]> => {
  try {
    let q = collection(db, collectionName);

    // Apply filters
    if (filters && filters.length > 0) {
      const constraints = filters.map((filter) =>
        where(filter.field, filter.operator, filter.value)
      );
      q = query(q, ...constraints) as any;
    }

    // Apply ordering
    if (orderByField) {
      q = query(q, orderBy(orderByField, orderDirection)) as any;
    }

    // Apply limit
    if (limitCount) {
      q = query(q, limit(limitCount)) as any;
    }

    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    })) as T[];
  } catch (error) {
    console.error('Error querying documents:', error);
    throw error;
  }
};
